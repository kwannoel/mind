---
title: Stream fusion in Haskell
date: "2020-08-07"
tags:
    - SICP
    - Haskell
---

Stream fusion takes a simple 3-step approach:
1. Convert recursive structures to non-recursive structures
2. Eliminate superfluous conversions between structures and costructures
3. Use general optimisations to fuse co-structure code.

We can transform pipelines of recursive list functions into non-recursive ones, and easily optimize.

We explicitly represent the sequence co-structure as the `Stream` type.

### Step 1

Convert lists to streams, run the stream co-structure equivalent functions, convert back to list.

For example for `map`:

```hs
map :: (a -> b) -> [a] -> [b]
map f = toList . S.map f . fromList -- S.map refers to the map functions for streams
                                    -- fromList converts from a list to stream
                                    -- toList converts from a stream to list
```

Next, we have to define our streams
```hs
data Stream a = forall s. Stream (s -> Step a s) s -- ^ Note the existential quantification here
data Step a s = Done
              | Yield a s
              | Skip s
```

Recognize the similarities between `Stream` data constructor and [unfoldr](https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-List.html#v:unfoldr)
```
Stream  :: forall s a. (s -> Step a, s)    -> s -> Stream a
unfoldr :: forall s a. (s -> Maybe (a, s)) -> s -> s [a]
```

Observe that Stream is **not a recursive structure**. You can see both `map` and `fromList` definitions for intuition:

```hs
map :: (a -> b) -> Stream a -> Stream b
map f (Stream next s) = Stream next' s
  where
    next s = case next of
      Done -> Done
      Skip s' -> Skip
      Yield x s' -> Yield (f x) s'
      
fromList :: [a] -> Stream a
fromList ls = Stream next xs
  where
    next [] = Done
    next (x:xs) = Yield x xs
```

Why is **non-recursive** required?

How does this optimize lists?

What is an example of optimization?

How does allocation work for lists?

---

References:
[Stream Fusion paper](http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.104.7401&rep=rep1&type=pdf)
[Clear explanation + Benchmarking for streams - StackBuilders](https://www.stackbuilders.com/tutorials/haskell/ghc-optimization-and-fusion/)
