---
title: Writer Monad
date: "2020-06-21"
tags:
    - blog
    - Haskell
    - Monad
---

Imagine you have a function, `f` which takes in an argument `a`, produces a result `b`.

Now, you want log the input

In languages like Javascript where "functions" can produce effects, you could probably capture it in a state variable:

```js
let log = ""

function addOne (n) {
  log = log + `Adding one to ${n}`
  return n + 1
}
```

In haskell since functions have to be pure, perhaps you could do something like this:

```hs
type Log = String

addOne :: Int -> (Log, Int)
addOne n = ("Adding one to " <> show n, n + 1)
```

Continuing on, we want to use the result, let's call it `res` and we'd like to `addOne` again

```hs
res :: (Log, Int)
res = addOne 1
```

We have to lift `addOne`'s first argument into the `(Log,)` context to do so:

```hs
addOne' :: (Log, Int) -> (Log, Int)
addOne' (log, n) = let (log2, n2) = addOne n
                   in (log ++ log2, n2)
```

This is still readable, but is there some way we can abstract some of this away?

If we observe `log ++ log2` it seems like a process we will repeat each time, combining `logs` whenever we call an adding function.

We also know the actual logic is in `addOne`, not `addOne'` which is a wrapper around `addOne`, allowing us to combine the `logs`.

Hence we would like some way to abstract this away, so we don't have to write boilerplate code to add the logs each time.

Let's first consider `log ++ log2`. These can be considered the monadic contexts.

Knowing the type signature of `(>>=)` is `Monad m => m a -> (a -> m b) -> m b`
We can do something like

```hs
data WriterL a = WriterL (Log, a)

class Monad WriterL where 
    return a = ("", a)
    f1 >=> f2 = \a -> let (l1, b) = f1 a
                          (l2, c) = f2 b
                      in  (l1 <> l2, c)
```

We can then use `>=>` to compose `addOne`s, composing the underlying functionality and combining the contexts, in this case the logs.

We do realize however, that `a -> m b` means that the composed function only looks at `a`, the way it treats the previous context in `m a` is fixed, when we defined the `>=>` operator. It concatenates the logs.

Hence, we would not be able to `view` the logs along the way if we wanted to. The definition has made the `log` implicit.

Let's explore another construct to do this, the <8a11e368>.
