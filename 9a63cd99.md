---
title: "Zippers in Haskell and Javascript (Part 2)"
date: "2020-07-25"
tags:
    - Haskell
    - Zippers
    - Javascript
    - blog
---

**IN PROGRESS**

We've seen a zipper being implemented in Haskell, now let's talk about a concrete example for using Zippers in Javascript.

In the frontend development if we follow elm architecture, we separate our program into: 
- **Model** - The application state
- **View** - Turning your state into HTML
- **Update** - Update your state via messages

Of interest to us are the `view` and `update` components mentioned.

Suppose you have a table rendered in your html:
| Favourite languages | Interesting projects      |
|---------------------|---------------------------|
| Haskell             | Pandoc, Servant, Parsec   |
| Rust                | Diesel, gameboy, redox-os |
| Javascript          | Monet.js, Immutable.js    |

The intuitive underlying architecture should be like so:
```js
[
  { language: "Haskell"
  , projects: ["Pandoc", "Servant", "Parsec"]
  }
, { language: "Rust"
  , projects: ["Diesel", "gameboy", "redox-os"]
  }
, { language: "Javascript"
  , projects: ["Monet.js", "Immutable.js"]
  }
]
```

Suppose now we want to add another project to Haskell, `QuickCheck`:
| Favourite languages | Interesting projects                    |
|---------------------|-----------------------------------------|
| Haskell             | Pandoc, Servant, Parsec, **QuickCheck** |
| Rust                | Diesel, gameboy, redox-os               |
| Javascript          | Monet.js, Immutable.js                  |

Our state should look like this:
```js
[
  { language: "Haskell"
  , projects: ["Pandoc", "Servant", "Parsec", "QuickCheck"]
  }                                           // We appended QuickCheck here
, { language: "Rust"
  , projects: ["Diesel", "gameboy", "redox-os"]
  }
, { language: "Javascript"
  , projects: ["Monet.js", "Immutable.js"]
  }
]
```

One way would be to access the projects array for `Haskell` and mutate it:
```js
state.forEach(row => {
  row.language === "Haskell" // Access the row for Haskell
    ? row.projects // Access the projects array
         .push("QuickCheck") // mutate the projects array
    : {}
})
```

This is not ideal however. It is difficult to find the source of side effects since they are not strictly local.

How can we do this in a pure way instead?

We want use reducers which do `updates` to state in a pure way.

If we just have this:
```js
const addRowProject = (projects, newProject) => {
  return projects.concat(newProject)
}
```

We can provide a path and traverse down the state:
```js
const addProject = (project, newProject) => 
  state.map(row => 
    row.language === project
      ? { ..row, projects: row.projects.concat(newProject) }
      : row)
```

However the traversal step takes extra time for us, making it inefficient.

Instead, we can provide the context as we traverse down the state, mapping the view and update components
```jsx
renderTable = (tableState) => {
  return (
    ...
    <TableHeaders />
    {tableState.map(row => renderRow(row))}
    ...
  )
}
```

In this case our context will be the other rows.

We also provide the location, which is the row itself.

With all these information we can update without having to traverse each time:
```js
const addProject = (leftRows, rightRows, row, newProject) => {
  return leftRows.concat({..row, projects: row.projects.concat(newProject)})
                 .concat(rightRows)
}
```

Part 3 - To be continued... Swapping rows.

References:
[Elm guide](https://guide.elm-lang.org/architecture/)
